Условие:
Ответ: 4953
Решение:
count = 0

for i in range(2, 20001):
    lst = [1]
    for j in range(2, int(i ** 0.5) + 1):
        if i % j == 0:
            lst.append(j)
            lst.append(i // j)
    if i < sum(set(lst)):
        count += 1

print(count)

Условие:
Решение:
def f(n):
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return 0
    return 1


def fn(n):
    for i in range(2, int(n ** 0.5) + 1):
        a = f(i)
        if n % i == 0 and i > 100 and a:
            return i
        elif n % i == 0 and i < 100 and a:
            return 0


for i in range(20222022, 2022, -1):
    a = fn(i)
    if not f(i) and a:
        print(i, a)

Условие:
Источник: https://kpolyakov.spb.ru/
Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [126849; 126871],
числа, имеющие ровно 4 различных делителя.
Выведите эти четыре делителя для каждого найденного числа в порядке возрастания.
В ответе запишите через пробел сначала 4 делителя в порядке возрастания для первого найденного числа,
потом для второго, и так далее для всех найженных чисел.
Решение:
import math


def prime_factors(n):
    lst = set()
    lst.add(1)
    lst.add(n)
    for j in range(2, int(math.sqrt(n) + 1)):
        if n % j == 0:
            lst.add(j)
            lst.add(n // j)
    return list(map(str, sorted(lst)))


for i in range(126849, 126871):
    a = prime_factors(i)
    if len(a) == 4:
        print(' '.join(a))

Условие:
Задача с сайта https://kpolyakov.spb.ru/

Среди целых чисел, принадлежащих числовому отрезку [268312;336492],
найдите числа, которые представляют собой произведение двух различных простых делителей.
Запишите в ответе количество таких чисел и минимальное из них.

Решение:
import math


for i in range(12034679, 23175821):
    lst = set()
    if math.sqrt(i) == int(math.sqrt(i)):
        for j in range(2, int(math.sqrt(i)) + 1):
            if i % j == 0:
                lst.add(j)
                lst.add(i // j)
                if len(lst) > 3:
                    break
    if len(lst) == 3:
        print(i, max(lst))


Условие:
Задача с сайта https://kpolyakov.spb.ru/

Среди целых чисел, принадлежащих числовому отрезку [268312;336492],
найдите числа, которые представляют собой произведение двух различных простых делителей.
Запишите в ответе количество таких чисел и минимальное из них.
Решение:
import math


def f(n):
    for g in range(2, int(math.sqrt(n)) + 1):
        if n % g == 0:
            return False
    return True


count = 0
br = set()
for i in range(268312, 336492):
    ls = set()
    for j in range(2, int(math.sqrt(i)) + 1):
        if i % j == 0 and f(j) and f(i // j) and j != (i // j):
            br.add(i)
            count += 1
            break

print(count, min(br))

Условие:
Источник: ЕГЭ-2022

Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
— символ «?» означает ровно одну произвольную цифру;
— символ «*» означает любую последовательность цифр произвольной длины;
в том числе «*» может задавать и пустую последовательность.
Среди натуральных чисел, не превышающих 108, найдите все числа,
соответствующие маске 12*4?65, делящиеся на 161 без остатка.
В ответе запишите сначала наименьшее найденное число, затем, через пробел,
частное от его деления на 161, затем, через пробел,
следующее по величине найденное число, затем, через пробел,
частное от его деления на 161, и так далее для всех найденных чисел.
Решение:
from fnmatch import fnmatch

for i in range(161, 10 ** 8, 161):
    if fnmatch(str(i), '12*4?65'):
        print(i, i // 161)

Условие:
Школково #49389
Среди целых чисел, принадлежащих числовому отрезку [173225; 217437],
найдите числа, которые представляют собой произведение двух различных простых делителей,
заканчивающихся на одну и ту же цифру.
Запишите в ответе количество таких чисел и минимальное из них без разделителей.
Решение:
import math


def f(n):
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True


count = 0
lst = []
for x in range(173225, 217438):
    for j in range(2, int(math.sqrt(x)) + 1):
        if x % j == 0 and f(j) and f(x // j) and (j != x // j) and (str(j)[-1] == str(x // j)[-1]):
            count += 1
            lst.append(x)
            break
print(str(count) + str(min(lst)))

Условие:
Школково #54938
Дан числовой отрезок [28454;28598].
Для данного числового отрезка найдите число,
имеющее максимальное количество различных натуральных делителей.
В случае равенства количества делителей данных чисел, найдите максимальное из них.
В качестве ответа запишите без пробелов и разделителей найденное число и количество делителей этого числа.
Решение:
import math

bibi = []
for x in range(28560, 28560 + 1):
    count = set()
    for j in range(2, int(math.sqrt(x)) + 1):
        if x % j == 0:
            count.add(j)
        if x % (x // j) == 0:
            count.add(x // j)
    bibi.append([x, len(count) + 2])
print(''.join(map(str, max(bibi, key=lambda x: (x[1], x[0])))))

Условие:
Школково #61232
Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [14678; 15156],
числа удовлетворяющие условию: разность максимального и минимального различных делителей,
отличных от единицы и самого числа, больше 7570.
В ответе через пробел запишите пары чисел в порядке возрастания первых чисел в паре:
число и разность максимального и минимального делителей этого числа.
Пример ввода ответа: число1 разность1 число2 разность2 ...
Решение:
import math

for x in range(14678, 15156 + 1):
    de = set()
    for i in range(2, int(math.sqrt(x)) + 1):
        if x % i == 0:
            de.add(i)
            de.add(x // i)
    if len(de) > 1:
        diff = max(de) - min(de)
        if diff > 7570:
            print(x, diff)

Условие:
Школково #80727

Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
– символ «?» означает ровно одну произвольную цифру;
– символ «*» означает любую последовательность цифр произвольной длины;
в том числе «*» может задавать и пустую последовательность.
Например, маске 123*4?5 соответствуют числа 123405 и 12300405.
Среди натуральных чисел, не превышающих 10 ** 10, найдите последние пять чисел, соответствующие маске 9?99*16,
делящиеся на 1724 без остатка.
В ответ запишите пары чисел (найденное число и результат деления его на 1724) в порядке возрастания через пробел
Решение:
from fnmatch import fnmatch

for i in range(1724, 10 ** 10, 1724):
    if fnmatch(str(i), '9?99*16'):
        print(i, i // 1724)

Условие:
Школково #80728

Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
– символ «?» означает ровно одну произвольную цифру;
– символ «*» означает любую последовательность цифр произвольной длины;
в том числе «*» может задавать и пустую последовательность.
Например, маске 123*4?5 соответствуют числа 123405 и 12300405.
Среди натуральных чисел, не превышающих 10 ** 10, найдите последние пять чисел, соответствующие маске ?3*313?,
делящиеся на 8965 без остатка.
В ответ запишите пары чисел (найденное число и результат деления его на 8965) в порядке возрастания через пробел.
Решение:
from fnmatch import fnmatch

for i in range(8965, 10 ** 10, 8965):
    if fnmatch(str(i), '?3*313?'):
        print(i, i // 8965)

Условие:
Школково #80724

Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
– символ «?» означает ровно одну произвольную цифру;
– символ «&» означает последовательность из ровно двух произвольных цифр.
– символ «*» означает любую последовательность цифр произвольной длины;
в том числе «*» может задавать и пустую последовательность.
Например, маске 123&4?5 соответствуют числа 12389405 и 12332405.
Среди натуральных чисел, не превышающих 10 ** 9, найдите все числа,
соответствующие маске 69?73&0*, делящиеся на 8080 без остатка.
В ответ запишите пары чисел (найденное число и результат деления его на 8080) в порядке возрастания через пробел.

Решение:
from fnmatch import fnmatch

for i in range(8080, 10 ** 9, 8080):
    if fnmatch(str(i), '69?73??0*'):  # вместо & будем использовать два ?
        print(i, i // 8080)

Условие:
Школково #83917

Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
– символ «?» означает ровно одну произвольную цифру;
– символ «*» означает любую последовательность цифр произвольной длины;
в том числе «*» может задавать и пустую последовательность.
Например, маске 123*4?5 соответствуют числа 123405 и 12300405.
Среди натуральных чисел, не превышающих 10**9, найдите все числа, соответствующие маске ?4?8*15?5,
делящиеся на 4215 без остатка и частные от деления найденных чисел на 4215.
В ответ запишите пары найденных чисел (найденное число и частное от деления на 4215) в порядке возрастания через пробел.
Решение:
from fnmatch import fnmatch

for i in range(4215, 10 ** 9, 4215):
    if fnmatch(str(i), '?4?8*15?5'):
        print(i, i // 4215)



