ВАЖНАЯ ЗАМЕТКА!!!!!
ОБЯЗАТЕЛЬНО В методе replace() прописывать 1 в конце, чтобы замена происходила лишь 1 итерацию
Также не очень понимаю, имеем ли мы возможность не прописывать условия, а просто писать replace.


Условие:
https://3.shkolkovo.online/catalog/4522/6051?SubjectId=30
Решение:
a = 125 * '7'
while '777' in a:
    a = a.replace('7777', '6', 1)
    a = a.replace('666', '7')

print(a)

Условие:
https://3.shkolkovo.online/catalog/7524/6298?SubjectId=30
Решение:
a = '*' + '2' * 100 + '5' * 10 + '9' * 60

while '*2' in a or '*5' in a or '*9' in a:
    a = a.replace('*2', '*')
    a = a.replace('*5', '6*', 1)
    a = a.replace('*9', '7*', 1)

a = a.replace('*', '')

print(max(a, key=lambda x: a.count(x)))

Условие:
https://3.shkolkovo.online/catalog/7524/7519?SubjectId=30
Решение:
def f(s: str):
    while '*1' in s or '*5' in s:
        if '*51' in s:
            s = s.replace('*51', '9*', 1)
        elif '*5' in s:
            s = s.replace('*5', '0*', 1)
        s = s.replace('*1', '1*', 1)
    return s


# тут чисто поразмышляем.
# в алгоритме видим, что 51 заменяется на 9. какое самое близкое число к 29, которое делится на 9?
# это 27
# получается, что нам надо *515151, так мы получим *999, что в сумме дает 27
# но 29 - 27 = 2. Но посмотрите на условие, нам нужно 5 единиц, а мы использовали всего 3.
# та самая недостающая двойка как раз берется за счет тех двух 1
# так что алгоритм ниже будет сделан лишь ради проверки

s1 = '*' + '515151' + '11'
s2 = '*' + '11' + '515151'
fs1, fs2 = f(s1), f(s2)
fs1, fs2 = fs1.replace('*', ''), fs2.replace('*', '')
if sum(map(int, fs1)) == 29:
    print(s1.count('5'))
    print('s1 работает')
if sum(map(int, fs2)) == 29:
    print(s2.count('5'))
    print('s2 работает')
