def f(s: str):
    while '*1' in s or '*5' in s:
        if '*51' in s:
            s = s.replace('*51', '9*', 1)
        elif '*5' in s:
            s = s.replace('*5', '0*', 1)
        s = s.replace('*1', '1*', 1)
    return s


# тут чисто поразмышляем.
# в алгоритме видим, что 51 заменяется на 9. какое самое близкое число к 29, которое делится на 9?
# это 27
# получается, что нам надо *515151, так мы получим *999, что в сумме дает 27
# но 29 - 27 = 2. Но посмотрите на условие, нам нужно 5 единиц, а мы использовали всего 3.
# та самая недостающая двойка как раз берется за счет тех двух 1
# так что алгоритм ниже будет сделан лишь ради проверки

s1 = '*' + '515151' + '11'
s2 = '*' + '11' + '515151'
fs1, fs2 = f(s1), f(s2)
fs1, fs2 = fs1.replace('*', ''), fs2.replace('*', '')
if sum(map(int, fs1)) == 29:
    print(s1.count('5'))
    print('s1 работает')
if sum(map(int, fs2)) == 29:
    print(s2.count('5'))
    print('s2 работает')
